// Based on condenseErrors() from https://github.com/swagger-api/swagger-editor
//
// 1. group all errors by path
// 2. score them by message frequency
// 3. select the most frequent messages (retaining all equally-frequent messages)
// 4. concatenate the params of each occurrence of the most frequent message
// 5. create one condensed error for the path
export class ErrorCondenser {
    constructor(errors) {
        this.errors = errors;
        this.parseToTree();
    }
    condense() {
        const condensedErrors = Object.keys(this.tree).flatMap((path) => {
            const frequentMessageErrors = this.detectMostFrequentMessageNames(path).map((name) => this.tree[path][name]);
            return frequentMessageErrors.map(this.mergeDuplicatedErrors.bind(this));
        });
        return this.filterRedundantIfKeywords(condensedErrors);
    }
    parseToTree() {
        this.tree = this.errors.reduce((res, err) => {
            var _a;
            const { instancePath, message } = err;
            res[instancePath] = {
                ...(res[instancePath] || {}),
                [message]: [...(((_a = res[instancePath]) === null || _a === void 0 ? void 0 : _a[message]) || []), err]
            };
            return res;
        }, {});
    }
    detectMostFrequentMessageNames(path) {
        return Object.keys(this.tree[path]).reduce((obj, msg) => {
            const count = this.tree[path][msg].length;
            if (count > obj.max) {
                return {
                    messages: [msg],
                    max: count
                };
            }
            else if (count === obj.max) {
                obj.messages.push(msg);
            }
            return obj;
        }, { max: 0, messages: [] }).messages;
    }
    mergeDuplicatedErrors(errors) {
        return errors.reduce((prev, err) => Object.assign({}, prev, {
            ...(!prev.params && !err.params
                ? {}
                : { params: this.mergeParameterObjects(prev.params, err.params) })
        }));
    }
    arrayify(thing) {
        return thing == null || Array.isArray(thing) ? thing : [thing];
    }
    mergeParameterObjects(objA = {}, objB = {}) {
        const res = {};
        (objA ? Object.keys(objA) : []).forEach((k) => {
            res[k] = this.arrayify(objA[k]);
        });
        (objB ? Object.keys(objB) : []).forEach((k) => {
            res[k] = [...(res[k] || []), ...this.arrayify(objB[k])];
        });
        return res;
    }
    filterRedundantIfKeywords(errors) {
        const paths = Object.keys(this.tree);
        const nonBranchingPaths = new Set(errors
            .filter((error) => error.keyword !== 'if' && error.keyword !== 'anyOf')
            .map((error) => error.instancePath));
        return errors.filter((error) => {
            if (error.keyword !== 'if' && error.keyword !== 'anyOf') {
                return true;
            }
            if (nonBranchingPaths.has(error.instancePath)) {
                return false;
            }
            return paths
                .filter((path) => path !== error.instancePath)
                .every((path) => !path.startsWith(error.instancePath));
        });
    }
}
//# sourceMappingURL=ErrorCondenser.js.map