import { BaseFormatter } from './BaseFormatter';
import { WordingHelper } from './WordingHelper';
const formatLabelsMap = {
    'date-time': 'date and time',
    'time': 'time',
    'date': 'date',
    'duration': 'duration',
    'email': 'email address',
    'idn-email': 'internationalized email address',
    'hostname': 'host name',
    'idn-hostname': 'internationalized host name',
    'ipv4': 'IPv4 address',
    'ipv6': 'IPv6 address',
    'uuid': 'unique identifier',
    'uri': 'URI',
    'uri-reference': 'URI reference',
    'iri': 'internationalized URI',
    'iri-reference': 'internationalized URI reference',
    'uri-template': 'URI template',
    'json-pointer': 'JSON pointer',
    'relative-json-pointer': 'relative JSON pointer',
    'regex': 'regular expression'
};
export class StringFormatter extends BaseFormatter {
    constructor() {
        super(...arguments);
        this.supportedKeywords = new Set([
            'minLength',
            'maxLength',
            'pattern',
            'format'
        ]);
    }
    format(error) {
        const target = WordingHelper.humanizeTarget(error.instancePath);
        switch (error.keyword) {
            case 'minLength':
            case 'maxLength':
                return `${target} must have a value of length ${error.params.limit} or ${WordingHelper.humanizeComparison(error.keyword)} characters`;
            case 'pattern':
                return `${target} must have a value that matches the pattern \`${error.params.pattern}\``;
            case 'format':
                return `${target} must have a value that is a valid ${formatLabelsMap[error.params.format] || error.params.format} string`;
        }
    }
}
//# sourceMappingURL=StringFormatter.js.map